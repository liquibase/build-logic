name: Linux packaging
on:
  workflow_call:
    inputs:
      groupId:
        description: "Value from the groupId field in pom.xml. i.e. org.liquibase"
        required: true
        type: string
      artifactId:
        description: "Value from the artifactId field in pom.xml. i.e. liquibase"
        required: true
        type: string
      version:
        description: "Value from the version field in pom.xml. i.e 4.23.0"
        type: string
      dry_run:
        description: "Flag to indicate if the workflow is triggered to create a dry-run release"
        required: false
        type: boolean
        default: false
      dry_run_zip_url:
        description: "URL of the dry-run zip release"
        required: false
        type: string
      dry_run_tar_gz_url:
        description: "URL of the dry-run tar.gz release"
        required: false
        type: string
      dry_run_release_id:
        description: "ID of the dry-run release"
        required: false
        type: string
      distribution:
        description: "liquibase or liquibase-secure"
        required: false
        type: string
        default: "liquibase"
      download_base_url:
        description: "Base URL for downloading artifacts"
        required: false
        type: string
        default: "https://github.com/liquibase/liquibase/releases/download"

  workflow_dispatch:
    inputs:
      groupId:
        description: "Value from the groupId field in pom.xml. i.e. org.liquibase"
        required: true
        type: string
      artifactId:
        description: "Value from the artifactId field in pom.xml. i.e. liquibase"
        required: true
        type: string
      version:
        description: "Value from the version field in pom.xml. i.e 4.23.0"
        type: string
      dry_run:
        description: "Flag to indicate if the workflow is triggered to create a dry-run release"
        required: false
        type: boolean
        default: false
      dry_run_zip_url:
        description: "URL of the dry-run zip release"
        required: false
        type: string
      dry_run_tar_gz_url:
        description: "URL of the dry-run tar.gz release"
        required: false
        type: string
      dry_run_release_id:
        description: "ID of the dry-run release"
        required: false
        type: string
      distribution:
        description: "liquibase or liquibase-secure"
        required: false
        type: string
        default: "liquibase"
      download_base_url:
        description: "Base URL for downloading artifacts"
        required: false
        type: string
        default: "https://github.com/liquibase/liquibase/releases/download"

env:
  MAVEN_VERSION: "3.9.5"

permissions:
  id-token: write
  contents: write
  pull-requests: write
  issues: write # Required for creating/updating issues
  packages: write # Required for package operations
  actions: write # Required for workflow operations

jobs:
  upload_packages:
    name: Upload ${{ inputs.artifactId }} packages
    runs-on: ubuntu-22.04
    outputs:
      HOMEBREW_PR_NUMBER: ${{ steps.capture-pr.outputs.HOMEBREW_PR_NUMBER }}
      HOMEBREW_PR_URL: ${{ steps.capture-pr.outputs.HOMEBREW_PR_URL }}
    steps:
      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          permission-contents: write
          permission-actions: write

      - uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v5
        with:
          java-version: "21"
          distribution: "temurin"
          cache: "maven"

      - name: Set up Maven
        uses: stCarolas/setup-maven@v5
        with:
          maven-version: ${{ env.MAVEN_VERSION }}

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.1.4

      - name: Get Reusable Files
        run: |
          # Under the src folder is where specific packages files live. The GitHub action inputs will modify the universal package-deb-pom.xml to tell the process which assets to use during the packaging step
          # Determine the correct source directory and package name based on distribution
          if [ "${{ inputs.distribution }}" = "liquibase-secure" ]; then
            SRC_DIR="liquibase-secure"
            PACKAGE_NAME="liquibase-secure"
          else
            SRC_DIR="${{ inputs.artifactId }}"
            PACKAGE_NAME="${{ inputs.artifactId }}"
          fi

          # Export for use in later steps
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV

          mkdir -p $PWD/.github/src/$PACKAGE_NAME/deb/control
          mkdir -p $PWD/.github/src/$PACKAGE_NAME/main/archive
          curl -o $PWD/.github/src/$PACKAGE_NAME/deb/control/control https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/deb/control/control
          curl -o $PWD/.github/src/$PACKAGE_NAME/deb/control/postinst https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/deb/control/postinst
          curl -o $PWD/.github/src/$PACKAGE_NAME/deb/control/postrm https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/deb/control/postrm
          curl -o $PWD/.github/src/$PACKAGE_NAME/main/archive/$PACKAGE_NAME-env.sh https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/main/archive/${SRC_DIR}-env.sh

          # Download appropriate pom.xml based on distribution
          if [ "${{ inputs.distribution }}" = "liquibase-secure" ]; then
            curl -o $PWD/.github/package-deb-pom.xml https://raw.githubusercontent.com/liquibase/build-logic/main/.github/package-deb-pom-secure.xml
          else
            curl -o $PWD/.github/package-deb-pom.xml https://raw.githubusercontent.com/liquibase/build-logic/main/.github/package-deb-pom.xml
          fi
          curl -o $PWD/.github/sign_artifact.sh https://raw.githubusercontent.com/liquibase/build-logic/main/.github/sign_artifact.sh
          chmod +x $PWD/.github/sign_artifact.sh

      - name: Convert escaped newlines and set GPG key
        run: |
          GPG_KEY_CONTENT="$(printf '%b' "${{ env.GPG_SECRET }}")"
          {
            echo "GPG_KEY_CONTENT<<GPG_EOF"
            echo "$GPG_KEY_CONTENT"
            echo
            echo "GPG_EOF"
          } >> $GITHUB_ENV
          GPG_KEY_CONTENT="${GPG_KEY_CONTENT//%/%25}"
          GPG_KEY_CONTENT="${GPG_KEY_CONTENT//$'\r'/%0D}"
          GPG_KEY_CONTENT="${GPG_KEY_CONTENT//$'\n'/%0A}"
          echo "::add-mask::${GPG_KEY_CONTENT}"

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_PROD_GITHUB_OIDC_ROLE_ARN_BUILD_LOGIC }}
          aws-region: us-east-1

      - name: Download ${{ inputs.artifactId }} Release
        if: ${{ inputs.dry_run == false }}
        run: |
          mkdir -p $PWD/.github/target
          if [ "${{ inputs.distribution }}" = "liquibase-secure" ]; then
            # Download from S3 for liquibase-secure
            wget -q -O $PWD/.github/target/liquibase-secure-${{ inputs.version }}.tar.gz \
              ${{ inputs.download_base_url }}/${{ inputs.version }}/liquibase-secure-${{ inputs.version }}.tar.gz
          else
            # Download from GitHub for liquibase (community)
            wget -q -O $PWD/.github/target/${{ inputs.artifactId }}-${{ inputs.version }}.tar.gz \
              ${{ inputs.download_base_url }}/v${{ inputs.version }}/${{ inputs.artifactId }}-${{ inputs.version }}.tar.gz
          fi

      - name: Download ${{ inputs.artifactId }} dry-run Release
        if: ${{ inputs.dry_run == true }}
        uses: robinraju/release-downloader@v1.12
        with:
          repository: "liquibase/liquibase"
          releaseId: "${{ inputs.dry_run_release_id }}"
          fileName: "*"
          out-file-path: ".github/target/"
          token: "${{ steps.get-token.outputs.token }}"

      - name: Build ${{ inputs.artifactId }} deb package
        run: |
          mvn package -f $PWD/.github/package-deb-pom.xml -DgroupId=${{ inputs.groupId }} -DartifactId=${{ env.PACKAGE_NAME }} -Drevision=${{ inputs.version }} -DskipTests

      - name: Install deb-s3 gem
        run: gem install deb-s3

      - name: Import GPG key for deb signing
        if: ${{ inputs.dry_run == false }}
        id: import_gpg_deb
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Upload ${{ inputs.artifactId }} deb package
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          # Debug: List available GPG keys
          echo "Available GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Get the actual key ID from the imported key
          ACTUAL_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using key ID: $ACTUAL_KEY_ID"

          # Create temporary passphrase file securely (not logged)
          TEMP_PASSPHRASE_FILE=$(mktemp)
          echo "${{ env.GPG_PASSPHRASE }}" > "$TEMP_PASSPHRASE_FILE"
          chmod 600 "$TEMP_PASSPHRASE_FILE"

          deb-s3 upload --preserve-versions --sign "$ACTUAL_KEY_ID" --gpg-options "\-\-pinentry-mode loopback \-\-batch \-\-passphrase\-file $TEMP_PASSPHRASE_FILE \-\-yes \-\-quiet" --bucket repo.liquibase.com --visibility=nil $PWD/.github/target/${{ env.PACKAGE_NAME }}-${{ inputs.version }}.deb

          # Securely clean up passphrase file
          rm -f "$TEMP_PASSPHRASE_FILE"

      - name: Import GPG key for dry-run deb signing
        if: ${{ inputs.dry_run == true }}
        id: import_gpg_deb_dryrun
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Upload ${{ inputs.artifactId }} dry-run deb package
        if: ${{ inputs.dry_run == true }}
        continue-on-error: true
        run: |
          # Debug: List available GPG keys
          echo "Available GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Get the actual key ID from the imported key
          ACTUAL_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using key ID: $ACTUAL_KEY_ID"

          # Create temporary passphrase file securely (not logged)
          TEMP_PASSPHRASE_FILE=$(mktemp)
          echo "${{ env.GPG_PASSPHRASE }}" > "$TEMP_PASSPHRASE_FILE"
          chmod 600 "$TEMP_PASSPHRASE_FILE"

          deb-s3 upload --preserve-versions --sign "$ACTUAL_KEY_ID" --gpg-options "\-\-pinentry-mode loopback \-\-batch \-\-passphrase\-file $TEMP_PASSPHRASE_FILE \-\-yes \-\-quiet" --bucket repo.liquibase.com.dry.run --visibility=nil $PWD/.github/target/${{ env.PACKAGE_NAME }}-${{ inputs.version }}.deb

          # Securely clean up passphrase file
          rm -f "$TEMP_PASSPHRASE_FILE"

      - name: Import GPG key for dry-run RPM signing
        if: ${{ inputs.dry_run == true }}
        id: import_gpg_rpm_dryrun
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Sign dry-run RPM package
        if: ${{ inputs.dry_run == true }}
        continue-on-error: true
        run: |
          # Install rpm-sign package
          sudo apt-get install -y rpm

          # Fix ownership of RPM file (alien creates it as root)
          sudo chown $(whoami):$(whoami) "${{ env.RPM_FILENAME }}"

          # Get the GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using GPG key ID: $GPG_KEY_ID"

          # Set GPG environment to avoid TTY warnings
          export GPG_TTY=$(tty)

          # Import GPG public key into RPM database
          gpg --export -a "$GPG_KEY_ID" > /tmp/gpg-pubkey.asc
          sudo rpm --import /tmp/gpg-pubkey.asc
          rm /tmp/gpg-pubkey.asc

          # Create RPM macros file for signing
          printf '%%_signature gpg\n' > ~/.rpmmacros
          printf '%%_gpg_name GPG_KEY_ID_PLACEHOLDER\n' >> ~/.rpmmacros
          printf '%%__gpg /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%_gpg_path ~/.gnupg\n' >> ~/.rpmmacros
          printf '%%_gpgbin /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%__gpg_sign_cmd %%{__gpg} --batch --no-verbose --no-armor --pinentry-mode loopback --passphrase "GPG_PASSPHRASE_PLACEHOLDER" --no-secmem-warning -u "%%{_gpg_name}" -sbo %%{__signature_filename} %%{__plaintext_filename}\n' >> ~/.rpmmacros

          # Replace placeholders in .rpmmacros
          sed -i "s/GPG_KEY_ID_PLACEHOLDER/$GPG_KEY_ID/g" ~/.rpmmacros
          sed -i "s/GPG_PASSPHRASE_PLACEHOLDER/${{ env.GPG_PASSPHRASE }}/g" ~/.rpmmacros

          # Verify .rpmmacros was created successfully (without displaying sensitive content)
          if [ -f ~/.rpmmacros ]; then
            echo "✓ RPM macros file created successfully"
          else
            echo "✗ ERROR: Failed to create RPM macros file"
            exit 1
          fi

          # Test GPG signing capability (redirect output to avoid exposing sensitive data)
          echo "Testing GPG signing capability..."
          if echo "test" | gpg --batch --no-verbose --armor --pinentry-mode loopback --passphrase "${{ env.GPG_PASSPHRASE }}" --no-secmem-warning -u "$GPG_KEY_ID" --clearsign > /dev/null 2>&1; then
            echo "✓ GPG signing test successful"
          else
            echo "✗ WARNING: GPG signing test failed"
          fi

          # Sign the RPM (filter output to avoid exposing sensitive data)
          echo "Signing RPM: ${{ env.RPM_FILENAME }}"
          if rpm --addsign "${{ env.RPM_FILENAME }}" 2>&1 | grep -v "passphrase" > /tmp/rpm-sign-output.txt; then
            echo "✓ RPM signing completed"
          else
            # Check if signing actually worked
            if grep -q "error" /tmp/rpm-sign-output.txt; then
              echo "✗ ERROR: RPM signing encountered errors"
              grep -i "error" /tmp/rpm-sign-output.txt
            else
              echo "✓ RPM signing completed (with warnings)"
            fi
          fi

          # Verify the signature with verbose output
          echo "Verifying RPM signature:"
          rpm --checksig -v "${{ env.RPM_FILENAME }}" || true

          # Check if signature was actually added
          echo "Checking if RPM has a GPG signature:"
          if rpm --checksig "${{ env.RPM_FILENAME }}" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is successfully signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          # Also check with query
          echo "Checking RPM signature with query:"
          rpm -qip "${{ env.RPM_FILENAME }}" | grep -i signature || echo "No signature info in package header"

      - name: Invalidate CloudFront cache
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          # Get CloudFront distribution ID for repo.liquibase.com
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Aliases.Items[?@=='repo.liquibase.com']].Id" \
            --output text)

          if [ -n "$DISTRIBUTION_ID" ]; then
            echo "Invalidating CloudFront cache for distribution: $DISTRIBUTION_ID"
            aws cloudfront create-invalidation \
              --distribution-id "$DISTRIBUTION_ID" \
              --paths "/dists/stable/*"
            echo "CloudFront cache invalidation created for /dists/stable/*"
          else
            echo "Warning: Could not find CloudFront distribution for repo.liquibase.com"
          fi

      - name: Convert deb to rpm
        continue-on-error: true
        run: |
          sudo apt-get update
          sudo apt-get install -y alien
          sudo alien --to-rpm --keep-version $PWD/.github/target/${{ env.PACKAGE_NAME }}-${{ inputs.version }}.deb
          # Find the actual generated RPM file (alien may change naming)
          RPM_FILE=$(ls -1 *.rpm 2>/dev/null | head -1)
          if [ -n "$RPM_FILE" ]; then
            echo "Generated RPM: $RPM_FILE"
            # For liquibase-secure, ensure the RPM has the correct name format
            EXPECTED_RPM="${{ env.PACKAGE_NAME }}-${{ inputs.version }}-1.noarch.rpm"
            if [ "$RPM_FILE" != "$EXPECTED_RPM" ]; then
              echo "Renaming $RPM_FILE to $EXPECTED_RPM"
              mv "$RPM_FILE" "$EXPECTED_RPM"
              RPM_FILE="$EXPECTED_RPM"
            fi
            echo "RPM_FILENAME=$RPM_FILE" >> $GITHUB_ENV
          else
            echo "Error: No RPM file found after conversion"
            exit 1
          fi

      - name: Import GPG key for RPM signing
        if: ${{ inputs.dry_run == false }}
        id: import_gpg_rpm
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Sign RPM package
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          # Install rpm-sign package
          sudo apt-get install -y rpm

          # Fix ownership of RPM file (alien creates it as root)
          sudo chown $(whoami):$(whoami) "${{ env.RPM_FILENAME }}"

          # Get the GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using GPG key ID: $GPG_KEY_ID"

          # Set GPG environment to avoid TTY warnings
          export GPG_TTY=$(tty)

          # Import GPG public key into RPM database
          gpg --export -a "$GPG_KEY_ID" > /tmp/gpg-pubkey.asc
          sudo rpm --import /tmp/gpg-pubkey.asc
          rm /tmp/gpg-pubkey.asc

          # Create RPM macros file for signing
          printf '%%_signature gpg\n' > ~/.rpmmacros
          printf '%%_gpg_name GPG_KEY_ID_PLACEHOLDER\n' >> ~/.rpmmacros
          printf '%%__gpg /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%_gpg_path ~/.gnupg\n' >> ~/.rpmmacros
          printf '%%_gpgbin /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%__gpg_sign_cmd %%{__gpg} --batch --no-verbose --no-armor --pinentry-mode loopback --passphrase "GPG_PASSPHRASE_PLACEHOLDER" --no-secmem-warning -u "%%{_gpg_name}" -sbo %%{__signature_filename} %%{__plaintext_filename}\n' >> ~/.rpmmacros

          # Replace placeholders in .rpmmacros
          sed -i "s/GPG_KEY_ID_PLACEHOLDER/$GPG_KEY_ID/g" ~/.rpmmacros
          sed -i "s/GPG_PASSPHRASE_PLACEHOLDER/${{ env.GPG_PASSPHRASE }}/g" ~/.rpmmacros

          # Verify .rpmmacros was created successfully (without displaying sensitive content)
          if [ -f ~/.rpmmacros ]; then
            echo "✓ RPM macros file created successfully"
          else
            echo "✗ ERROR: Failed to create RPM macros file"
            exit 1
          fi

          # Test GPG signing capability (redirect output to avoid exposing sensitive data)
          echo "Testing GPG signing capability..."
          if echo "test" | gpg --batch --no-verbose --armor --pinentry-mode loopback --passphrase "${{ env.GPG_PASSPHRASE }}" --no-secmem-warning -u "$GPG_KEY_ID" --clearsign > /dev/null 2>&1; then
            echo "✓ GPG signing test successful"
          else
            echo "✗ WARNING: GPG signing test failed"
          fi

          # Sign the RPM (filter output to avoid exposing sensitive data)
          echo "Signing RPM: ${{ env.RPM_FILENAME }}"
          if rpm --addsign "${{ env.RPM_FILENAME }}" 2>&1 | grep -v "passphrase" > /tmp/rpm-sign-output.txt; then
            echo "✓ RPM signing completed"
          else
            # Check if signing actually worked
            if grep -q "error" /tmp/rpm-sign-output.txt; then
              echo "✗ ERROR: RPM signing encountered errors"
              grep -i "error" /tmp/rpm-sign-output.txt
            else
              echo "✓ RPM signing completed (with warnings)"
            fi
          fi

          # Verify the signature with verbose output
          echo "Verifying RPM signature:"
          rpm --checksig -v "${{ env.RPM_FILENAME }}" || true

          # Check if signature was actually added
          echo "Checking if RPM has a GPP signature:"
          if rpm --checksig "${{ env.RPM_FILENAME }}" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is successfully signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          # Also check with query
          echo "Checking RPM signature with query:"
          rpm -qip "${{ env.RPM_FILENAME }}" | grep -i signature || echo "No signature info in package header"

      - name: Upload ${{ inputs.artifactId }} rpm package
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          sudo apt-get install -y libcurl4-openssl-dev libbz2-dev libxml2-dev libssl-dev zlib1g-dev pkg-config libglib2.0-dev liblzma-dev libsqlite0-dev libsqlite3-dev librpm-dev libzstd-dev python3 cmake

          # Get absolute path to the signed RPM file
          SIGNED_RPM_PATH="$(pwd)/${{ env.RPM_FILENAME }}"
          echo "Signed RPM location: $SIGNED_RPM_PATH"

          # Verify the signed RPM exists and is actually signed
          if [ ! -f "$SIGNED_RPM_PATH" ]; then
            echo "✗ ERROR: Signed RPM not found at $SIGNED_RPM_PATH"
            exit 1
          fi

          echo "Verifying RPM signature before upload:"
          if rpm --checksig "$SIGNED_RPM_PATH" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          mkdir -p createrepo_folder
          cd createrepo_folder
          git clone https://github.com/rpm-software-management/createrepo_c
          cd createrepo_c
          mkdir -p build
          cd build
          # Modified CMake command with additional flags to properly disable documentation
          cmake .. -DWITH_ZCHUNK=NO -DWITH_LIBMODULEMD=NO -DENABLE_DRPM=NO -DENABLE_PYTHON=NO -DENABLE_DOCS=NO -DDISABLE_DOCUMENTATION_TARGET=ON || echo "CMake configuration failed but continuing..."
          make -j || echo "Build failed but continuing..."

          # Check if createrepo_c was built, otherwise try to find system createrepo
          if [ -f src/createrepo_c ]; then
            cp src/createrepo_c /opt/createrepo
          elif command -v createrepo_c &> /dev/null; then
            echo "Using system createrepo_c instead"
            ln -sf $(which createrepo_c) /opt/createrepo
          elif command -v createrepo &> /dev/null; then
            echo "Using system createrepo instead"
            ln -sf $(which createrepo) /opt/createrepo
          else
            echo "Installing createrepo-c from package manager as fallback"
            sudo apt-get install -y createrepo-c
            ln -sf $(which createrepo_c) /opt/createrepo
          fi

          # Return to workspace root
          cd $GITHUB_WORKSPACE

          # Create YUM repository directory structure
          mkdir -p yum/noarch

          # Download existing RPMs from S3 (excluding the current version to avoid conflicts)
          echo "Downloading existing RPMs from S3..."
          aws s3 ls s3://repo.liquibase.com/yum/noarch/ | grep -E '\.rpm$' | awk '{print $4}' | while read rpm; do
            # Skip if it's the same version we're uploading
            if [[ "$rpm" != "${{ env.RPM_FILENAME }}" ]]; then
              aws s3 cp "s3://repo.liquibase.com/yum/noarch/$rpm" yum/noarch/
            fi
          done

          # Copy the signed RPM to the repository directory
          echo "Copying signed RPM to repository..."
          cp "$SIGNED_RPM_PATH" yum/noarch/

          # Verify the copied file is still signed
          echo "Verifying copied RPM signature:"
          rpm --checksig "yum/noarch/${{ env.RPM_FILENAME }}"

          # Generate repository metadata with the signed RPM
          echo "Generating repository metadata..."
          /opt/createrepo -dp yum/noarch

          # Sign the repository metadata
          echo "Signing repository metadata..."
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          gpg --batch --pinentry-mode loopback --passphrase '${{ env.GPG_PASSPHRASE }}' --detach-sign --armor -u "$GPG_KEY_ID" yum/noarch/repodata/repomd.xml

          # Upload to S3
          echo "Uploading repository to S3..."
          aws s3 sync yum s3://repo.liquibase.com/yum --delete

          echo "✓ RPM repository updated successfully"

      - name: Upload ${{ inputs.artifactId }} dry-run rpm package
        if: ${{ inputs.dry_run == true }}
        continue-on-error: true
        run: |
          sudo apt-get install -y libcurl4-openssl-dev libbz2-dev libxml2-dev libssl-dev zlib1g-dev pkg-config libglib2.0-dev liblzma-dev libsqlite0-dev libsqlite3-dev librpm-dev libzstd-dev python3 cmake

          # Get absolute path to the signed RPM file
          SIGNED_RPM_PATH="$(pwd)/${{ env.RPM_FILENAME }}"
          echo "Signed RPM location: $SIGNED_RPM_PATH"

          # Verify the signed RPM exists and is actually signed
          if [ ! -f "$SIGNED_RPM_PATH" ]; then
            echo "✗ ERROR: Signed RPM not found at $SIGNED_RPM_PATH"
            exit 1
          fi

          echo "Verifying RPM signature before upload:"
          if rpm --checksig "$SIGNED_RPM_PATH" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          mkdir -p createrepo_folder
          cd createrepo_folder
          git clone https://github.com/rpm-software-management/createrepo_c
          cd createrepo_c
          mkdir -p build
          cd build
          # Modified CMake command with additional flags to properly disable documentation
          cmake .. -DWITH_ZCHUNK=NO -DWITH_LIBMODULEMD=NO -DENABLE_DRPM=NO -DENABLE_PYTHON=NO -DENABLE_DOCS=NO -DDISABLE_DOCUMENTATION_TARGET=ON || echo "CMake configuration failed but continuing..."
          make -j || echo "Build failed but continuing..."

          # Check if createrepo_c was built, otherwise try to find system createrepo
          if [ -f src/createrepo_c ]; then
            cp src/createrepo_c /opt/createrepo
          elif command -v createrepo_c &> /dev/null; then
            echo "Using system createrepo_c instead"
            ln -sf $(which createrepo_c) /opt/createrepo
          elif command -v createrepo &> /dev/null; then
            echo "Using system createrepo instead"
            ln -sf $(which createrepo) /opt/createrepo
          else
            echo "Installing createrepo from package manager as fallback"
            sudo apt-get install -y createrepo
            ln -sf $(which createrepo) /opt/createrepo
          fi

          # Return to workspace root
          cd $GITHUB_WORKSPACE

          # Create YUM repository directory structure
          mkdir -p yum/noarch

          # Download existing RPMs from S3 (excluding the current version to avoid conflicts)
          echo "Downloading existing RPMs from S3..."
          aws s3 ls s3://repo.liquibase.com.dry.run/yum/noarch/ | grep -E '\.rpm$' | awk '{print $4}' | while read rpm; do
            # Skip if it's the same version we're uploading
            if [[ "$rpm" != "${{ env.RPM_FILENAME }}" ]]; then
              aws s3 cp "s3://repo.liquibase.com.dry.run/yum/noarch/$rpm" yum/noarch/
            fi
          done

          # Copy the signed RPM to the repository directory
          echo "Copying signed RPM to repository..."
          cp "$SIGNED_RPM_PATH" yum/noarch/

          # Verify the copied file is still signed
          echo "Verifying copied RPM signature:"
          rpm --checksig "yum/noarch/${{ env.RPM_FILENAME }}"

          # Generate repository metadata with the signed RPM
          echo "Generating repository metadata..."
          /opt/createrepo -dp yum/noarch

          # Sign the repository metadata
          echo "Signing repository metadata..."
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          gpg --batch --pinentry-mode loopback --passphrase '${{ env.GPG_PASSPHRASE }}' --detach-sign --armor -u "$GPG_KEY_ID" yum/noarch/repodata/repomd.xml

          # Upload to S3
          echo "Uploading repository to S3..."
          aws s3 sync yum s3://repo.liquibase.com.dry.run/yum --delete

          echo "✓ RPM repository updated successfully"

      - name: Check for existing Homebrew formula PR for ${{ inputs.distribution }}
        if: ${{ inputs.distribution != 'liquibase-secure' && startsWith(inputs.version, '4.') }}
        continue-on-error: true
        id: check-brew-pr
        run: |
          # Authenticate GitHub CLI
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

          # Define the PR title
          pr_title="${{ inputs.distribution }} ${{ inputs.version }}"

          # Search for open pull requests with the specified title in the Homebrew/homebrew-core repo
          pr_title=$(gh pr list --repo Homebrew/homebrew-core --state open --search "$pr_title" --json title --jq ".[] | select(.title == \"$pr_title\") | .title" )
          echo "pr_title: $pr_title"
          # Set the environment variable based on whether the PR exists
          if [ -z "$pr_title" ]; then
            PR_EXISTS=false
          else
            PR_EXISTS=true
          fi

          # Store it in GitHub output for later steps
          echo "PR_EXISTS=$PR_EXISTS" >> $GITHUB_OUTPUT

          # Echo it immediately to see the value in logs
          echo "PR_EXISTS is set to $PR_EXISTS"

      - name: Update Homebrew formula for ${{ inputs.distribution }}
        if: ${{ inputs.distribution != 'liquibase-secure' && startsWith(inputs.version, '4.') && steps.check-brew-pr.outputs.PR_EXISTS == 'false' && inputs.dry_run == false }}
        continue-on-error: true
        uses: mislav/bump-homebrew-formula-action@v3
        with:
          formula-name: ${{ inputs.distribution }}
          formula-path: Formula/l/${{ inputs.distribution }}.rb
          homebrew-tap: Homebrew/homebrew-core
          tag-name: ${{ inputs.version }}
          download-url: ${{ inputs.distribution == 'liquibase-secure' && format('{0}/{1}/liquibase-secure-{1}.tar.gz', inputs.download_base_url, inputs.version) || format('{0}/v{1}/{2}-{1}.tar.gz', inputs.download_base_url, inputs.version, inputs.artifactId) }}
          commit-message: |
            {{formulaName}} {{version}}

            Created by https://github.com/mislav/bump-homebrew-formula-action
        env:
          COMMITTER_TOKEN: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}

      # This step captures the PR details after it has been created
      # and stores the PR number and URL in GitHub outputs for later use.
      # This is useful for tracking the PR status and creating a tracking issue.
      - name: Capture Homebrew PR Details
        continue-on-error: true
        if: ${{ inputs.distribution != 'liquibase-secure' && startsWith(inputs.version, '4.') && steps.check-brew-pr.outputs.PR_EXISTS == 'false' && inputs.dry_run == false }}
        id: capture-pr
        run: |
          # Wait briefly for PR to be created
          sleep 30

          # Search for the PR
          PR_DATA=$(gh api graphql -f query='
          query($search_query: String!) {
            search(query: $search_query, type: ISSUE, first: 1) {
              nodes {
                ... on PullRequest {
                  url,
                  number
                }
              }
            }
          }' -f search_query="is:pr is:open repo:Homebrew/homebrew-core liquibase ${{ inputs.version }} in:title" --jq '.data.search.nodes[0]')

          if [ ! -z "$PR_DATA" ]; then
            echo "HOMEBREW_PR_URL=$(echo "$PR_DATA" | jq -r '.url')" >> $GITHUB_OUTPUT
            echo "HOMEBREW_PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')" >> $GITHUB_OUTPUT
            echo "Found Homebrew PR #$(echo "$PR_DATA" | jq -r '.url')"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update SDKMAN version for ${{ inputs.artifactId }}
        if: ${{ inputs.distribution == 'liquibase' && inputs.dry_run == false }}
        continue-on-error: true
        env:
          SDKMAN_CONSUMER_KEY: ${{ env.SDKMAN_CONSUMER_KEY }}
          SDKMAN_CONSUMER_TOKEN: ${{ env.SDKMAN_CONSUMER_TOKEN }}
          VERSION: ${{ inputs.version }}
          WEB_URL: https://package.liquibase.com/downloads/oss/sdkman/
          S3_BUCKET: s3://repo.liquibase.com/sdkman/oss/
        run: |
          set -e  # Exit on any error

          # Download the zip file for liquibase (community edition only)
          wget -q -O liquibase-$VERSION.zip ${{ inputs.download_base_url }}/v$VERSION/liquibase-$VERSION.zip
          ZIP_FILENAME="liquibase-$VERSION.zip"
          SDKMAN_CANDIDATE="liquibase"
          mkdir -p liquibase-$VERSION/bin/internal
          unzip $ZIP_FILENAME -d liquibase-$VERSION
          rm -rf $ZIP_FILENAME
          mv ./liquibase-$VERSION/liquibase ./liquibase-$VERSION/bin/
          mv ./liquibase-$VERSION/liquibase.bat ./liquibase-$VERSION/bin/
          zip -r $ZIP_FILENAME ./liquibase-$VERSION
          # Upload the release to S3
          aws s3 cp $ZIP_FILENAME $S3_BUCKET
          echo "Uploaded $ZIP_FILENAME to s3"

          # Send the release to SDKMAN
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          -H "Consumer-Key: $SDKMAN_CONSUMER_KEY" \
          -H "Consumer-Token: $SDKMAN_CONSUMER_TOKEN" \
          -H "Content-Type: application/json" \
          -H "Accept: application/json" \
          -d '{"candidate": "'"$SDKMAN_CANDIDATE"'", "version": "'"$VERSION"'", "url": "'"$WEB_URL$ZIP_FILENAME"'"}' \
          https://vendors.sdkman.io/release)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          echo "SDKMAN release response: $RESPONSE_BODY"
          if [ "$HTTP_CODE" -ge 400 ]; then
            echo "ERROR: Failed to release to SDKMAN (HTTP $HTTP_CODE): $RESPONSE_BODY"
            exit 1
          fi
          echo "Sent $ZIP_FILENAME to SDKMAN"

          # Set the default version for SDKMAN
          RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
          -H "Consumer-Key: $SDKMAN_CONSUMER_KEY" \
          -H "Consumer-Token: $SDKMAN_CONSUMER_TOKEN" \
          -H "Content-Type: application/json" \
          -H "Accept: application/json" \
          -d '{"candidate": "'"$SDKMAN_CANDIDATE"'", "version": "'"$VERSION"'"}' \
          https://vendors.sdkman.io/default)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          echo "SDKMAN default response: $RESPONSE_BODY"
          if [ "$HTTP_CODE" -ge 400 ]; then
            echo "ERROR: Failed to set default version in SDKMAN (HTTP $HTTP_CODE): $RESPONSE_BODY"
            exit 1
          fi
          echo "Set $ZIP_FILENAME as default version for SDKMAN"

          # Announce the release to SDKMAN
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          -H "Consumer-Key: $SDKMAN_CONSUMER_KEY" \
          -H "Consumer-Token: $SDKMAN_CONSUMER_TOKEN" \
          -H "Content-Type: application/json" \
          -H "Accept: application/json" \
          -d '{"candidate": "'"$SDKMAN_CANDIDATE"'", "version": "'"$VERSION"'", "url": "https://github.com/liquibase/liquibase/releases/tag/v'"$VERSION"'"}' \
          https://vendors.sdkman.io/announce/struct)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          echo "SDKMAN announce response: $RESPONSE_BODY"
          if [ "$HTTP_CODE" -ge 400 ]; then
            echo "ERROR: Failed to announce to SDKMAN (HTTP $HTTP_CODE): $RESPONSE_BODY"
            exit 1
          fi
          echo "Announced $ZIP_FILENAME to SDKMAN"

      - name: Update SDKMAN version for ${{ inputs.artifactId }} dry-run
        if: ${{ inputs.distribution == 'liquibase' && inputs.dry_run == true }}
        continue-on-error: true
        env:
          SDKMAN_CONSUMER_KEY: ${{ env.SDKMAN_CONSUMER_KEY }}
          SDKMAN_CONSUMER_TOKEN: ${{ env.SDKMAN_CONSUMER_TOKEN }}
          VERSION: ${{ inputs.version }}
          WEB_URL: https://s3.amazonaws.com/repo.liquibase.com.dry.run/sdkman
          S3_BUCKET: s3://repo.liquibase.com.dry.run/sdkman/
        run: |
          mkdir -p liquibase-$VERSION/bin/internal
          unzip .github/target/liquibase-$VERSION.zip -d liquibase-$VERSION
          rm -rf liquibase-$VERSION.zip
          mv ./liquibase-$VERSION/liquibase ./liquibase-$VERSION/bin/
          mv ./liquibase-$VERSION/liquibase.bat ./liquibase-$VERSION/bin/
          zip -r liquibase-$VERSION.zip ./liquibase-$VERSION
          # Upload the release to S3
          aws s3 cp liquibase-$VERSION.zip $S3_BUCKET
          echo "Uploaded liquibase-$VERSION.zip to s3"

  # create a placeholder branch to check if tracking branch exists for this version
  # Branch is created when package is submitted to Homebrew and SDKMAN
  # Branch is deleted when package becomes available on Homebrew and SDKMAN
  create-placeholder-branch:
    runs-on: ubuntu-latest
    needs: upload_packages
    if: ${{ inputs.distribution != 'liquibase-secure' && inputs.dry_run == false }}
    steps:
      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: liquibase

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: liquibase/liquibase
          token: ${{ steps.get-token.outputs.token }}

      - name: Configure Git
        run: |
          git config --local user.email "64099989+liquibot@users.noreply.github.com"
          git config --local user.name "liquibot"

      - name: Create placeholder branches for SDKMAN and Homebrew
        id: create-placeholder-branch
        run: |
          git fetch origin

          # Create SDKMAN tracking branch if it doesn't exist
          if ! git ls-remote --exit-code --heads origin ci-oss-sdkman-package-check; then
            git checkout -b ci-oss-sdkman-package-check
            echo "This is a placeholder branch for oss sdkman package v.${{ inputs.version }}. If this branch is open, it means the sdkman package is not yet approved" > README.md
            git add README.md
            git commit -m "Create placeholder branch for SDKMAN package v.${{ inputs.version }}"
            git push origin ci-oss-sdkman-package-check
          else
            echo "SDKMAN tracking branch already exists, skipping creation"
          fi

          # Create Homebrew tracking branch if it doesn't exist and PR number is available
          # Only create for 4.x versions due to Homebrew licensing restrictions
          if [[ "${{ inputs.version }}" =~ ^4\. ]] && [[ -n "${{ needs.upload_packages.outputs.HOMEBREW_PR_NUMBER }}" ]] && ! git ls-remote --exit-code --heads origin ci-oss-homebrew-package-check-${{ needs.upload_packages.outputs.HOMEBREW_PR_NUMBER }}; then
            git checkout -b ci-oss-homebrew-package-check-${{ needs.upload_packages.outputs.HOMEBREW_PR_NUMBER }}
            echo "This is a placeholder branch for oss homebrew package v.${{ inputs.version }}. If this branch is open, it means the homebrew package is not yet approved" > README.md
            git add README.md
            git commit -m "Create placeholder branch for Homebrew package v.${{ inputs.version }}"
            git push origin ci-oss-homebrew-package-check-${{ needs.upload_packages.outputs.HOMEBREW_PR_NUMBER }}
          else
            echo "Homebrew tracking branch skipped (only 4.x versions supported) or already exists or PR number not available"
          fi

  upload_windows_package:
    if: ${{ inputs.distribution == 'liquibase' }}
    uses: liquibase/liquibase-chocolatey/.github/workflows/deploy-package.yml@master
    secrets: inherit
    with:
      version: ${{ inputs.version }}
      dry_run: ${{ inputs.dry_run }}
      dry_run_zip_url: ${{ inputs.dry_run_zip_url }}

  # Chocolatey does not accept commercial/proprietary software in their community repository
  # This job is commented out as liquibase-secure cannot be distributed via Chocolatey
  # See: DAT-20985
  #upload_windows_secure_package:
  #  if: ${{ inputs.distribution == 'liquibase-secure' }}
  #  uses: liquibase/liquibase-secure-chocolatey/.github/workflows/deploy-package.yml@master
  #  secrets: inherit
  #  with:
  #    version: ${{ inputs.version }}
  #    dry_run: ${{ inputs.dry_run }}
  #    dry_run_zip_url: ${{ inputs.dry_run_zip_url }}

  upload_ansible_role:
    if: ${{ inputs.distribution == 'liquibase' }}
    uses: liquibase/liquibase-ansible/.github/workflows/deploy-role.yml@main
    secrets: inherit
    with:
      version: ${{ inputs.version }}
      dry_run: ${{ inputs.dry_run }}
      dry_run_release_id: ${{ inputs.dry_run_release_id }}

  upload_secure_ansible_role:
    if: ${{ inputs.distribution == 'liquibase-secure' }}
    uses: liquibase/liquibase-secure-ansible/.github/workflows/deploy-role.yml@main
    secrets: inherit
    with:
      version: ${{ inputs.version }}
      dry_run: ${{ inputs.dry_run }}
      dry_run_release_id: ${{ inputs.dry_run_release_id }}
