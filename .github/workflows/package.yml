name: Linux packaging
on:
  workflow_call:
    inputs:
      groupId:
        description: "Value from the groupId field in pom.xml. i.e. org.liquibase"
        required: true
        type: string
      artifactId:
        description: "Value from the artifactId field in pom.xml. i.e. liquibase"
        required: true
        type: string
      version:
        description: "Value from the version field in pom.xml. i.e 4.23.0"
        type: string
      dry_run:
        description: "Flag to indicate if the workflow is triggered to create a dry-run release"
        required: false
        type: boolean
        default: false
      dry_run_zip_url:
        description: "URL of the dry-run zip release"
        required: false
        type: string
      dry_run_tar_gz_url:
        description: "URL of the dry-run tar.gz release"
        required: false
        type: string
      dry_run_release_id:
        description: "ID of the dry-run release"
        required: false
        type: string
      distribution:
        description: "liquibase or liquibase-secure"
        required: false
        type: string
        default: "liquibase"
      download_base_url:
        description: "Base URL for downloading artifacts"
        required: false
        type: string
        default: "https://github.com/liquibase/liquibase/releases/download"

  workflow_dispatch:
    inputs:
      groupId:
        description: "Value from the groupId field in pom.xml. i.e. org.liquibase"
        required: true
        type: string
      artifactId:
        description: "Value from the artifactId field in pom.xml. i.e. liquibase"
        required: true
        type: string
      version:
        description: "Value from the version field in pom.xml. i.e 4.23.0"
        type: string
      dry_run:
        description: "Flag to indicate if the workflow is triggered to create a dry-run release"
        required: false
        type: boolean
        default: false
      dry_run_zip_url:
        description: "URL of the dry-run zip release"
        required: false
        type: string
      dry_run_tar_gz_url:
        description: "URL of the dry-run tar.gz release"
        required: false
        type: string
      dry_run_release_id:
        description: "ID of the dry-run release"
        required: false
        type: string
      distribution:
        description: "liquibase or liquibase-secure"
        required: false
        type: string
        default: "liquibase"
      download_base_url:
        description: "Base URL for downloading artifacts"
        required: false
        type: string
        default: "https://github.com/liquibase/liquibase/releases/download"

env:
  MAVEN_VERSION: "3.9.5"

permissions:
  id-token: write
  contents: write
  pull-requests: write
  issues: write # Required for creating/updating issues
  packages: write # Required for package operations
  actions: write # Required for workflow operations

jobs:
  upload_packages:
    name: Upload ${{ inputs.artifactId }} packages
    runs-on: ubuntu-22.04
    outputs:
      HOMEBREW_PR_NUMBER: ${{ steps.capture-pr.outputs.HOMEBREW_PR_NUMBER }}
      HOMEBREW_PR_URL: ${{ steps.capture-pr.outputs.HOMEBREW_PR_URL }}
    steps:
      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          permission-contents: write
          permission-actions: write

      - uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: "maven"

      - name: Set up Maven
        uses: stCarolas/setup-maven@v5
        with:
          maven-version: ${{ env.MAVEN_VERSION }}

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.1.4

      - name: Get Reusable Files
        run: |
          # Under the src folder is where specific packages files live. The GitHub action inputs will modify the universal package-deb-pom.xml to tell the process which assets to use during the packaging step
          # Determine the correct source directory and package name based on distribution
          if [ "${{ inputs.distribution }}" = "liquibase-secure" ]; then
            SRC_DIR="liquibase-secure"
            PACKAGE_NAME="liquibase-secure"
          else
            SRC_DIR="${{ inputs.artifactId }}"
            PACKAGE_NAME="${{ inputs.artifactId }}"
          fi

          # Export for use in later steps
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV

          mkdir -p $PWD/.github/src/$PACKAGE_NAME/deb/control
          mkdir -p $PWD/.github/src/$PACKAGE_NAME/main/archive
          curl -o $PWD/.github/src/$PACKAGE_NAME/deb/control/control https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/deb/control/control
          curl -o $PWD/.github/src/$PACKAGE_NAME/deb/control/postinst https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/deb/control/postinst
          curl -o $PWD/.github/src/$PACKAGE_NAME/deb/control/postrm https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/deb/control/postrm
          curl -o $PWD/.github/src/$PACKAGE_NAME/main/archive/$PACKAGE_NAME-env.sh https://raw.githubusercontent.com/liquibase/build-logic/main/src/${SRC_DIR}/main/archive/${SRC_DIR}-env.sh

          # Download appropriate pom.xml based on distribution
          if [ "${{ inputs.distribution }}" = "liquibase-secure" ]; then
            curl -o $PWD/.github/package-deb-pom.xml https://raw.githubusercontent.com/liquibase/build-logic/main/.github/package-deb-pom-secure.xml
          else
            curl -o $PWD/.github/package-deb-pom.xml https://raw.githubusercontent.com/liquibase/build-logic/main/.github/package-deb-pom.xml
          fi
          curl -o $PWD/.github/sign_artifact.sh https://raw.githubusercontent.com/liquibase/build-logic/main/.github/sign_artifact.sh
          chmod +x $PWD/.github/sign_artifact.sh

      - name: Convert escaped newlines and set GPG key
        run: |
          GPG_KEY_CONTENT="$(printf '%b' "${{ env.GPG_SECRET }}")"
          {
            echo "GPG_KEY_CONTENT<<GPG_EOF"
            echo "$GPG_KEY_CONTENT"
            echo
            echo "GPG_EOF"
          } >> $GITHUB_ENV
          GPG_KEY_CONTENT="${GPG_KEY_CONTENT//%/%25}"
          GPG_KEY_CONTENT="${GPG_KEY_CONTENT//$'\r'/%0D}"
          GPG_KEY_CONTENT="${GPG_KEY_CONTENT//$'\n'/%0A}"
          echo "::add-mask::${GPG_KEY_CONTENT}"

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_PROD_GITHUB_OIDC_ROLE_ARN_BUILD_LOGIC }}
          aws-region: us-east-1

      - name: Download ${{ inputs.artifactId }} Release
        if: ${{ inputs.dry_run == false }}
        run: |
          mkdir -p $PWD/.github/target
          if [ "${{ inputs.distribution }}" = "liquibase-secure" ]; then
            # Download from S3 for liquibase-secure
            wget -q -O $PWD/.github/target/liquibase-secure-${{ inputs.version }}.tar.gz \
              ${{ inputs.download_base_url }}/${{ inputs.version }}/liquibase-secure-${{ inputs.version }}.tar.gz
          else
            # Download from GitHub for liquibase (community)
            wget -q -O $PWD/.github/target/${{ inputs.artifactId }}-${{ inputs.version }}.tar.gz \
              ${{ inputs.download_base_url }}/v${{ inputs.version }}/${{ inputs.artifactId }}-${{ inputs.version }}.tar.gz
          fi

      - name: Download ${{ inputs.artifactId }} dry-run Release
        if: ${{ inputs.dry_run == true }}
        uses: robinraju/release-downloader@v1.12
        with:
          repository: "liquibase/liquibase"
          releaseId: "${{ inputs.dry_run_release_id }}"
          fileName: "*"
          out-file-path: ".github/target/"
          token: "${{ steps.get-token.outputs.token }}"

      - name: Build ${{ inputs.artifactId }} deb package
        run: |
          mvn package -f $PWD/.github/package-deb-pom.xml -DgroupId=${{ inputs.groupId }} -DartifactId=${{ env.PACKAGE_NAME }} -Drevision=${{ inputs.version }} -DskipTests

      - name: Install deb-s3 gem
        run: gem install deb-s3

      - name: Import GPG key for deb signing
        if: ${{ inputs.dry_run == false }}
        id: import_gpg_deb
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Upload ${{ inputs.artifactId }} deb package
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          # Debug: List available GPG keys
          echo "Available GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Get the actual key ID from the imported key
          ACTUAL_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using key ID: $ACTUAL_KEY_ID"

          # Create temporary passphrase file securely (not logged)
          TEMP_PASSPHRASE_FILE=$(mktemp)
          echo "${{ env.GPG_PASSPHRASE }}" > "$TEMP_PASSPHRASE_FILE"
          chmod 600 "$TEMP_PASSPHRASE_FILE"

          deb-s3 upload --preserve-versions --sign "$ACTUAL_KEY_ID" --gpg-options "\-\-pinentry-mode loopback \-\-batch \-\-passphrase\-file $TEMP_PASSPHRASE_FILE \-\-yes \-\-quiet" --bucket repo.liquibase.com --visibility=nil $PWD/.github/target/${{ env.PACKAGE_NAME }}-${{ inputs.version }}.deb

          # Securely clean up passphrase file
          rm -f "$TEMP_PASSPHRASE_FILE"

      - name: Import GPG key for dry-run deb signing
        if: ${{ inputs.dry_run == true }}
        id: import_gpg_deb_dryrun
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Upload ${{ inputs.artifactId }} dry-run deb package
        if: ${{ inputs.dry_run == true }}
        continue-on-error: true
        run: |
          # Debug: List available GPG keys
          echo "Available GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Get the actual key ID from the imported key
          ACTUAL_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using key ID: $ACTUAL_KEY_ID"

          # Create temporary passphrase file securely (not logged)
          TEMP_PASSPHRASE_FILE=$(mktemp)
          echo "${{ env.GPG_PASSPHRASE }}" > "$TEMP_PASSPHRASE_FILE"
          chmod 600 "$TEMP_PASSPHRASE_FILE"

          deb-s3 upload --preserve-versions --sign "$ACTUAL_KEY_ID" --gpg-options "\-\-pinentry-mode loopback \-\-batch \-\-passphrase\-file $TEMP_PASSPHRASE_FILE \-\-yes \-\-quiet" --bucket repo.liquibase.com.dry.run --visibility=nil $PWD/.github/target/${{ env.PACKAGE_NAME }}-${{ inputs.version }}.deb

          # Securely clean up passphrase file
          rm -f "$TEMP_PASSPHRASE_FILE"

      - name: Import GPG key for dry-run RPM signing
        if: ${{ inputs.dry_run == true }}
        id: import_gpg_rpm_dryrun
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Sign dry-run RPM package
        if: ${{ inputs.dry_run == true }}
        continue-on-error: true
        run: |
          # Install rpm-sign package
          sudo apt-get install -y rpm

          # Fix ownership of RPM file (alien creates it as root)
          sudo chown $(whoami):$(whoami) "${{ env.RPM_FILENAME }}"

          # Get the GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using GPG key ID: $GPG_KEY_ID"

          # Set GPG environment to avoid TTY warnings
          export GPG_TTY=$(tty)

          # Import GPG public key into RPM database
          gpg --export -a "$GPG_KEY_ID" > /tmp/gpg-pubkey.asc
          sudo rpm --import /tmp/gpg-pubkey.asc
          rm /tmp/gpg-pubkey.asc

          # Create RPM macros file for signing
          printf '%%_signature gpg\n' > ~/.rpmmacros
          printf '%%_gpg_name GPG_KEY_ID_PLACEHOLDER\n' >> ~/.rpmmacros
          printf '%%__gpg /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%_gpg_path ~/.gnupg\n' >> ~/.rpmmacros
          printf '%%_gpgbin /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%__gpg_sign_cmd %%{__gpg} --batch --no-verbose --no-armor --pinentry-mode loopback --passphrase "GPG_PASSPHRASE_PLACEHOLDER" --no-secmem-warning -u "%%{_gpg_name}" -sbo %%{__signature_filename} %%{__plaintext_filename}\n' >> ~/.rpmmacros

          # Replace placeholders in .rpmmacros
          sed -i "s/GPG_KEY_ID_PLACEHOLDER/$GPG_KEY_ID/g" ~/.rpmmacros
          sed -i "s/GPG_PASSPHRASE_PLACEHOLDER/${{ env.GPG_PASSPHRASE }}/g" ~/.rpmmacros

          # Verify .rpmmacros was created successfully (without displaying sensitive content)
          if [ -f ~/.rpmmacros ]; then
            echo "✓ RPM macros file created successfully"
          else
            echo "✗ ERROR: Failed to create RPM macros file"
            exit 1
          fi

          # Test GPG signing capability (redirect output to avoid exposing sensitive data)
          echo "Testing GPG signing capability..."
          if echo "test" | gpg --batch --no-verbose --armor --pinentry-mode loopback --passphrase "${{ env.GPG_PASSPHRASE }}" --no-secmem-warning -u "$GPG_KEY_ID" --clearsign > /dev/null 2>&1; then
            echo "✓ GPG signing test successful"
          else
            echo "✗ WARNING: GPG signing test failed"
          fi

          # Sign the RPM (filter output to avoid exposing sensitive data)
          echo "Signing RPM: ${{ env.RPM_FILENAME }}"
          if rpm --addsign "${{ env.RPM_FILENAME }}" 2>&1 | grep -v "passphrase" > /tmp/rpm-sign-output.txt; then
            echo "✓ RPM signing completed"
          else
            # Check if signing actually worked
            if grep -q "error" /tmp/rpm-sign-output.txt; then
              echo "✗ ERROR: RPM signing encountered errors"
              grep -i "error" /tmp/rpm-sign-output.txt
            else
              echo "✓ RPM signing completed (with warnings)"
            fi
          fi

          # Verify the signature with verbose output
          echo "Verifying RPM signature:"
          rpm --checksig -v "${{ env.RPM_FILENAME }}" || true

          # Check if signature was actually added
          echo "Checking if RPM has a GPG signature:"
          if rpm --checksig "${{ env.RPM_FILENAME }}" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is successfully signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          # Also check with query
          echo "Checking RPM signature with query:"
          rpm -qip "${{ env.RPM_FILENAME }}" | grep -i signature || echo "No signature info in package header"

      - name: Invalidate CloudFront cache
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          # Get CloudFront distribution ID for repo.liquibase.com
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Aliases.Items[?@=='repo.liquibase.com']].Id" \
            --output text)

          if [ -n "$DISTRIBUTION_ID" ]; then
            echo "Invalidating CloudFront cache for distribution: $DISTRIBUTION_ID"
            aws cloudfront create-invalidation \
              --distribution-id "$DISTRIBUTION_ID" \
              --paths "/dists/stable/*"
            echo "CloudFront cache invalidation created for /dists/stable/*"
          else
            echo "Warning: Could not find CloudFront distribution for repo.liquibase.com"
          fi

      - name: Convert deb to rpm
        continue-on-error: true
        run: |
          sudo apt-get update
          sudo apt-get install -y alien
          sudo alien --to-rpm --keep-version $PWD/.github/target/${{ env.PACKAGE_NAME }}-${{ inputs.version }}.deb
          # Find the actual generated RPM file (alien may change naming)
          RPM_FILE=$(ls -1 *.rpm 2>/dev/null | head -1)
          if [ -n "$RPM_FILE" ]; then
            echo "Generated RPM: $RPM_FILE"
            # For liquibase-secure, ensure the RPM has the correct name format
            EXPECTED_RPM="${{ env.PACKAGE_NAME }}-${{ inputs.version }}-1.noarch.rpm"
            if [ "$RPM_FILE" != "$EXPECTED_RPM" ]; then
              echo "Renaming $RPM_FILE to $EXPECTED_RPM"
              mv "$RPM_FILE" "$EXPECTED_RPM"
              RPM_FILE="$EXPECTED_RPM"
            fi
            echo "RPM_FILENAME=$RPM_FILE" >> $GITHUB_ENV
          else
            echo "Error: No RPM file found after conversion"
            exit 1
          fi

      - name: Import GPG key for RPM signing
        if: ${{ inputs.dry_run == false }}
        id: import_gpg_rpm
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ env.GPG_KEY_CONTENT }}
          passphrase: ${{ env.GPG_PASSPHRASE }}

      - name: Sign RPM package
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          # Install rpm-sign package
          sudo apt-get install -y rpm

          # Fix ownership of RPM file (alien creates it as root)
          sudo chown $(whoami):$(whoami) "${{ env.RPM_FILENAME }}"

          # Get the GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          echo "Using GPG key ID: $GPG_KEY_ID"

          # Set GPG environment to avoid TTY warnings
          export GPG_TTY=$(tty)

          # Import GPG public key into RPM database
          gpg --export -a "$GPG_KEY_ID" > /tmp/gpg-pubkey.asc
          sudo rpm --import /tmp/gpg-pubkey.asc
          rm /tmp/gpg-pubkey.asc

          # Create RPM macros file for signing
          printf '%%_signature gpg\n' > ~/.rpmmacros
          printf '%%_gpg_name GPG_KEY_ID_PLACEHOLDER\n' >> ~/.rpmmacros
          printf '%%__gpg /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%_gpg_path ~/.gnupg\n' >> ~/.rpmmacros
          printf '%%_gpgbin /usr/bin/gpg\n' >> ~/.rpmmacros
          printf '%%__gpg_sign_cmd %%{__gpg} --batch --no-verbose --no-armor --pinentry-mode loopback --passphrase "GPG_PASSPHRASE_PLACEHOLDER" --no-secmem-warning -u "%%{_gpg_name}" -sbo %%{__signature_filename} %%{__plaintext_filename}\n' >> ~/.rpmmacros

          # Replace placeholders in .rpmmacros
          sed -i "s/GPG_KEY_ID_PLACEHOLDER/$GPG_KEY_ID/g" ~/.rpmmacros
          sed -i "s/GPG_PASSPHRASE_PLACEHOLDER/${{ env.GPG_PASSPHRASE }}/g" ~/.rpmmacros

          # Verify .rpmmacros was created successfully (without displaying sensitive content)
          if [ -f ~/.rpmmacros ]; then
            echo "✓ RPM macros file created successfully"
          else
            echo "✗ ERROR: Failed to create RPM macros file"
            exit 1
          fi

          # Test GPG signing capability (redirect output to avoid exposing sensitive data)
          echo "Testing GPG signing capability..."
          if echo "test" | gpg --batch --no-verbose --armor --pinentry-mode loopback --passphrase "${{ env.GPG_PASSPHRASE }}" --no-secmem-warning -u "$GPG_KEY_ID" --clearsign > /dev/null 2>&1; then
            echo "✓ GPG signing test successful"
          else
            echo "✗ WARNING: GPG signing test failed"
          fi

          # Sign the RPM (filter output to avoid exposing sensitive data)
          echo "Signing RPM: ${{ env.RPM_FILENAME }}"
          if rpm --addsign "${{ env.RPM_FILENAME }}" 2>&1 | grep -v "passphrase" > /tmp/rpm-sign-output.txt; then
            echo "✓ RPM signing completed"
          else
            # Check if signing actually worked
            if grep -q "error" /tmp/rpm-sign-output.txt; then
              echo "✗ ERROR: RPM signing encountered errors"
              grep -i "error" /tmp/rpm-sign-output.txt
            else
              echo "✓ RPM signing completed (with warnings)"
            fi
          fi

          # Verify the signature with verbose output
          echo "Verifying RPM signature:"
          rpm --checksig -v "${{ env.RPM_FILENAME }}" || true

          # Check if signature was actually added
          echo "Checking if RPM has a GPP signature:"
          if rpm --checksig "${{ env.RPM_FILENAME }}" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is successfully signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          # Also check with query
          echo "Checking RPM signature with query:"
          rpm -qip "${{ env.RPM_FILENAME }}" | grep -i signature || echo "No signature info in package header"

      - name: Upload ${{ inputs.artifactId }} rpm package
        if: ${{ inputs.dry_run == false }}
        continue-on-error: true
        run: |
          sudo apt-get install -y libcurl4-openssl-dev libbz2-dev libxml2-dev libssl-dev zlib1g-dev pkg-config libglib2.0-dev liblzma-dev libsqlite0-dev libsqlite3-dev librpm-dev libzstd-dev python3 cmake

          # Get absolute path to the signed RPM file
          SIGNED_RPM_PATH="$(pwd)/${{ env.RPM_FILENAME }}"
          echo "Signed RPM location: $SIGNED_RPM_PATH"

          # Verify the signed RPM exists and is actually signed
          if [ ! -f "$SIGNED_RPM_PATH" ]; then
            echo "✗ ERROR: Signed RPM not found at $SIGNED_RPM_PATH"
            exit 1
          fi

          echo "Verifying RPM signature before upload:"
          if rpm --checksig "$SIGNED_RPM_PATH" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          mkdir -p createrepo_folder
          cd createrepo_folder
          git clone https://github.com/rpm-software-management/createrepo_c
          cd createrepo_c
          mkdir -p build
          cd build
          # Modified CMake command with additional flags to properly disable documentation
          cmake .. -DWITH_ZCHUNK=NO -DWITH_LIBMODULEMD=NO -DENABLE_DRPM=NO -DENABLE_PYTHON=NO -DENABLE_DOCS=NO -DDISABLE_DOCUMENTATION_TARGET=ON || echo "CMake configuration failed but continuing..."
          make -j || echo "Build failed but continuing..."

          # Check if createrepo_c was built, otherwise try to find system createrepo
          if [ -f src/createrepo_c ]; then
            cp src/createrepo_c /opt/createrepo
          elif command -v createrepo_c &> /dev/null; then
            echo "Using system createrepo_c instead"
            ln -sf $(which createrepo_c) /opt/createrepo
          elif command -v createrepo &> /dev/null; then
            echo "Using system createrepo instead"
            ln -sf $(which createrepo) /opt/createrepo
          else
            echo "Installing createrepo-c from package manager as fallback"
            sudo apt-get install -y createrepo-c
            ln -sf $(which createrepo_c) /opt/createrepo
          fi

          # Return to workspace root
          cd $GITHUB_WORKSPACE

          # Create YUM repository directory structure
          mkdir -p yum/noarch

          # Download existing RPMs from S3 (excluding the current version to avoid conflicts)
          echo "Downloading existing RPMs from S3..."
          aws s3 ls s3://repo.liquibase.com/yum/noarch/ | grep -E '\.rpm$' | awk '{print $4}' | while read rpm; do
            # Skip if it's the same version we're uploading
            if [[ "$rpm" != "${{ env.RPM_FILENAME }}" ]]; then
              aws s3 cp "s3://repo.liquibase.com/yum/noarch/$rpm" yum/noarch/
            fi
          done

          # Copy the signed RPM to the repository directory
          echo "Copying signed RPM to repository..."
          cp "$SIGNED_RPM_PATH" yum/noarch/

          # Verify the copied file is still signed
          echo "Verifying copied RPM signature:"
          rpm --checksig "yum/noarch/${{ env.RPM_FILENAME }}"

          # Generate repository metadata with the signed RPM
          echo "Generating repository metadata..."
          /opt/createrepo -dp yum/noarch

          # Sign the repository metadata
          echo "Signing repository metadata..."
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          gpg --batch --pinentry-mode loopback --passphrase '${{ env.GPG_PASSPHRASE }}' --detach-sign --armor -u "$GPG_KEY_ID" yum/noarch/repodata/repomd.xml

          # Upload to S3
          echo "Uploading repository to S3..."
          aws s3 sync yum s3://repo.liquibase.com/yum --delete

          echo "✓ RPM repository updated successfully"

      - name: Upload ${{ inputs.artifactId }} dry-run rpm package
        if: ${{ inputs.dry_run == true }}
        continue-on-error: true
        run: |
          sudo apt-get install -y libcurl4-openssl-dev libbz2-dev libxml2-dev libssl-dev zlib1g-dev pkg-config libglib2.0-dev liblzma-dev libsqlite0-dev libsqlite3-dev librpm-dev libzstd-dev python3 cmake

          # Get absolute path to the signed RPM file
          SIGNED_RPM_PATH="$(pwd)/${{ env.RPM_FILENAME }}"
          echo "Signed RPM location: $SIGNED_RPM_PATH"

          # Verify the signed RPM exists and is actually signed
          if [ ! -f "$SIGNED_RPM_PATH" ]; then
            echo "✗ ERROR: Signed RPM not found at $SIGNED_RPM_PATH"
            exit 1
          fi

          echo "Verifying RPM signature before upload:"
          if rpm --checksig "$SIGNED_RPM_PATH" 2>&1 | grep -q "RSA/SHA"; then
            echo "✓ RPM is signed with GPG signature"
          else
            echo "✗ WARNING: RPM may not be properly signed"
          fi

          mkdir -p createrepo_folder
          cd createrepo_folder
          git clone https://github.com/rpm-software-management/createrepo_c
          cd createrepo_c
          mkdir -p build
          cd build
          # Modified CMake command with additional flags to properly disable documentation
          cmake .. -DWITH_ZCHUNK=NO -DWITH_LIBMODULEMD=NO -DENABLE_DRPM=NO -DENABLE_PYTHON=NO -DENABLE_DOCS=NO -DDISABLE_DOCUMENTATION_TARGET=ON || echo "CMake configuration failed but continuing..."
          make -j || echo "Build failed but continuing..."

          # Check if createrepo_c was built, otherwise try to find system createrepo
          if [ -f src/createrepo_c ]; then
            cp src/createrepo_c /opt/createrepo
          elif command -v createrepo_c &> /dev/null; then
            echo "Using system createrepo_c instead"
            ln -sf $(which createrepo_c) /opt/createrepo
          elif command -v createrepo &> /dev/null; then
            echo "Using system createrepo instead"
            ln -sf $(which createrepo) /opt/createrepo
          else
            echo "Installing createrepo from package manager as fallback"
            sudo apt-get install -y createrepo
            ln -sf $(which createrepo) /opt/createrepo
          fi

          # Return to workspace root
          cd $GITHUB_WORKSPACE

          # Create YUM repository directory structure
          mkdir -p yum/noarch

          # Download existing RPMs from S3 (excluding the current version to avoid conflicts)
          echo "Downloading existing RPMs from S3..."
          aws s3 ls s3://repo.liquibase.com.dry.run/yum/noarch/ | grep -E '\.rpm$' | awk '{print $4}' | while read rpm; do
            # Skip if it's the same version we're uploading
            if [[ "$rpm" != "${{ env.RPM_FILENAME }}" ]]; then
              aws s3 cp "s3://repo.liquibase.com.dry.run/yum/noarch/$rpm" yum/noarch/
            fi
          done

          # Copy the signed RPM to the repository directory
          echo "Copying signed RPM to repository..."
          cp "$SIGNED_RPM_PATH" yum/noarch/

          # Verify the copied file is still signed
          echo "Verifying copied RPM signature:"
          rpm --checksig "yum/noarch/${{ env.RPM_FILENAME }}"

          # Generate repository metadata with the signed RPM
          echo "Generating repository metadata..."
          /opt/createrepo -dp yum/noarch

          # Sign the repository metadata
          echo "Signing repository metadata..."
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]\{16\}\).*/\1/')
          gpg --batch --pinentry-mode loopback --passphrase '${{ env.GPG_PASSPHRASE }}' --detach-sign --armor -u "$GPG_KEY_ID" yum/noarch/repodata/repomd.xml

          # Upload to S3
          echo "Uploading repository to S3..."
          aws s3 sync yum s3://repo.liquibase.com.dry.run/yum --delete

          echo "✓ RPM repository updated successfully"
