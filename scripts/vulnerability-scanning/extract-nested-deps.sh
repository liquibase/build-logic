#!/usr/bin/env bash
#
# extract-nested-deps.sh
#
# Unified extraction script for vulnerability scanning.
# Extracts nested JARs and Python packages from Docker images or tarballs.
#
# Usage:
#   extract-nested-deps.sh --mode=docker --source=<image_ref> [--scope=full|python-only]
#   extract-nested-deps.sh --mode=tarball --source=<tarball_path> [--scope=full|python-only]
#
# Arguments:
#   --mode      Required. Extraction mode: 'docker' or 'tarball'
#   --source    Required. Docker image reference or tarball file path
#   --scope     Optional. Scan scope: 'full' (default) or 'python-only'
#
# Environment Variables:
#   EXTRACT_DIR: Base directory for extraction (default: /tmp/extracted-deps)
#
# Outputs:
#   - Extracted JAR files in ${EXTRACT_DIR}/internal-jars/{lib,extensions} (docker mode, full scope)
#   - Nested JARs from archives in ${EXTRACT_DIR}/dist/ (docker mode, full scope)
#   - Python packages in ${EXTRACT_DIR}/python-packages
#   - Bundled wheels in ${EXTRACT_DIR}/python-bundled
#   - JAR mapping file in ${EXTRACT_DIR}/jar-mapping.txt
#   - Scanned JARs manifest in ${EXTRACT_DIR}/scanned-jars.txt

set -e

# Configuration
EXTRACT_DIR="${EXTRACT_DIR:-/tmp/extracted-deps}"
MODE=""
SOURCE=""
SCOPE="full"

# ============================================================================
# Argument Parsing
# ============================================================================

parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --mode=*)
        MODE="${1#*=}"
        ;;
      --source=*)
        SOURCE="${1#*=}"
        ;;
      --scope=*)
        SCOPE="${1#*=}"
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      *)
        echo "Error: Unknown argument: $1"
        show_help
        exit 1
        ;;
    esac
    shift
  done
}

show_help() {
  cat << 'EOF'
Usage:
  extract-nested-deps.sh --mode=docker --source=<image_ref> [--scope=full|python-only]
  extract-nested-deps.sh --mode=tarball --source=<tarball_path> [--scope=full|python-only]

Arguments:
  --mode      Required. Extraction mode: 'docker' or 'tarball'
  --source    Required. Docker image reference or tarball file path
  --scope     Optional. Scan scope: 'full' (default) or 'python-only'

Environment Variables:
  EXTRACT_DIR: Base directory for extraction (default: /tmp/extracted-deps)

Examples:
  # Docker mode - full extraction (nested JARs + Python)
  extract-nested-deps.sh --mode=docker --source=liquibase/liquibase:latest --scope=full

  # Docker mode - Python only
  extract-nested-deps.sh --mode=docker --source=liquibase/liquibase:latest --scope=python-only

  # Tarball mode - Python packages only
  extract-nested-deps.sh --mode=tarball --source=./liquibase-secure-5.0.0.tar.gz --scope=python-only
EOF
}

validate_arguments() {
  if [ -z "$MODE" ]; then
    echo "Error: --mode is required"
    show_help
    exit 1
  fi

  if [ -z "$SOURCE" ]; then
    echo "Error: --source is required"
    show_help
    exit 1
  fi

  if [ "$MODE" != "docker" ] && [ "$MODE" != "tarball" ]; then
    echo "Error: --mode must be 'docker' or 'tarball'"
    exit 1
  fi

  if [ "$SCOPE" != "full" ] && [ "$SCOPE" != "python-only" ]; then
    echo "Error: --scope must be 'full' or 'python-only'"
    exit 1
  fi

  # Validate source exists
  if [ "$MODE" = "tarball" ] && [ ! -f "$SOURCE" ]; then
    echo "Error: Tarball not found: $SOURCE"
    exit 1
  fi
}

# ============================================================================
# Docker Mode Functions
# ============================================================================

extract_from_docker() {
  local image_ref="$1"
  local scope="$2"

  echo "Extracting nested dependencies from Docker image: ${image_ref}..."

  # Create container from image to extract files
  container_id=$(docker create "${image_ref}")
  trap "docker rm ${container_id} > /dev/null 2>&1 || true" EXIT

  if [ "$scope" = "full" ]; then
    extract_dist_archives_docker "$container_id"
    extract_internal_jars_docker "$container_id"
  fi

  # Always extract Python packages
  extract_python_from_docker "$container_id"
}

extract_dist_archives_docker() {
  local container_id="$1"

  echo "Checking /liquibase/dist for tar.gz archives..."
  if docker cp "${container_id}:/liquibase/dist" /tmp/liquibase-dist 2>/dev/null; then
    echo "Found /liquibase/dist directory"

    # Extract all tar.gz archives
    find /tmp/liquibase-dist -name "*.tar.gz" -type f | while read -r archive; do
      archive_name=$(basename "$archive" .tar.gz)
      echo "  Extracting $archive_name..."
      extract_dir="/tmp/liquibase-dist/${archive_name}-extracted"
      mkdir -p "$extract_dir"
      tar -xzf "$archive" -C "$extract_dir" 2>/dev/null || true

      # Find JARs in extracted archive
      jar_count=$(find "$extract_dir" -name "*.jar" -type f | wc -l)
      if [ "$jar_count" -gt 0 ]; then
        echo "  Found $jar_count JAR(s) in $archive_name"

        # Extract each JAR from the archive
        find "$extract_dir" -name "*.jar" -type f | while read -r jar_file; do
          jar_name=$(basename "$jar_file" .jar)
          jar_extract="${EXTRACT_DIR}/dist/${archive_name}/${jar_name}"
          mkdir -p "$jar_extract"
          unzip -q "$jar_file" -d "$jar_extract" 2>/dev/null || true

          # Check for Spring Boot nested JARs and copy them as-is (don't extract)
          if [ -d "$jar_extract/BOOT-INF/lib" ]; then
            echo "    Spring Boot JAR: $jar_name - preserving nested JAR files"
            nested_count=0
            nested_jar_dir="${EXTRACT_DIR}/dist/${archive_name}/${jar_name}-nested-jars"
            mkdir -p "$nested_jar_dir"

            for nested_jar in "$jar_extract/BOOT-INF/lib"/*.jar; do
              if [ -f "$nested_jar" ]; then
                nested_count=$((nested_count + 1))
                nested_jar_name=$(basename "$nested_jar")

                # Copy the JAR file as-is, don't extract it
                cp "$nested_jar" "$nested_jar_dir/" 2>/dev/null || true

                # Record the parent -> nested relationship
                echo "${jar_name}.jar|$nested_jar_name" >> "${EXTRACT_DIR}/jar-mapping.txt"
              fi
            done
            echo "      Preserved $nested_count nested JAR file(s)"
          fi
        done
      fi
    done
  else
    echo "No /liquibase/dist directory found"
  fi
}

extract_internal_jars_docker() {
  local container_id="$1"

  echo "Extracting internal JARs..."
  if docker cp "${container_id}:/liquibase/internal" /tmp/liquibase-internal 2>/dev/null; then
    echo "Copied /liquibase/internal directory"

    # Count total JARs
    jar_count=$(find /tmp/liquibase-internal -name "*.jar" -type f | wc -l)
    echo "Found $jar_count JAR files to scan"

    # Copy all JAR files preserving them for Trivy to scan
    mkdir -p "${EXTRACT_DIR}/internal-jars/lib"
    mkdir -p "${EXTRACT_DIR}/internal-jars/extensions"

    # Copy lib JARs as-is
    if [ -d /tmp/liquibase-internal/lib ]; then
      cp /tmp/liquibase-internal/lib/*.jar "${EXTRACT_DIR}/internal-jars/lib/" 2>/dev/null || true
      lib_jar_count=$(ls -1 "${EXTRACT_DIR}/internal-jars/lib/"*.jar 2>/dev/null | wc -l)
      echo "  Preserved $lib_jar_count lib JAR(s)"
    fi

    # Copy extension JARs as-is
    if [ -d /tmp/liquibase-internal/extensions ]; then
      cp /tmp/liquibase-internal/extensions/*.jar "${EXTRACT_DIR}/internal-jars/extensions/" 2>/dev/null || true
      ext_jar_count=$(ls -1 "${EXTRACT_DIR}/internal-jars/extensions/"*.jar 2>/dev/null | wc -l)
      echo "  Preserved $ext_jar_count extension JAR(s)"
    fi

    echo "Preserved $jar_count JAR files for scanning"
  else
    echo "Warning: Could not copy /liquibase/internal directory"
  fi
}

extract_python_from_docker() {
  local container_id="$1"

  echo "Scanning extension JARs for Python packages..."
  mkdir -p "${EXTRACT_DIR}/python-packages"
  mkdir -p "${EXTRACT_DIR}/extension-scan"

  # Scan all JARs in internal-jars/extensions directory
  if [ -d "${EXTRACT_DIR}/internal-jars/extensions" ]; then
    extract_python_from_extensions "${EXTRACT_DIR}/internal-jars/extensions"
  elif [ -d /tmp/liquibase-internal/extensions ]; then
    # If we didn't copy JARs (python-only scope), scan from temp location
    extract_python_from_extensions /tmp/liquibase-internal/extensions
  else
    # Try to copy extensions for Python extraction
    if docker cp "${container_id}:/liquibase/internal/extensions" /tmp/liquibase-extensions 2>/dev/null; then
      extract_python_from_extensions /tmp/liquibase-extensions
    else
      echo "Warning: No extension JARs found for Python extraction"
    fi
  fi
}

# ============================================================================
# Tarball Mode Functions
# ============================================================================

extract_from_tarball() {
  local tarball_path="$1"
  local scope="$2"

  echo "Extracting nested dependencies from tarball: ${tarball_path}..."

  # Create extraction directories
  TARBALL_EXTRACT="/tmp/tarball-extract"
  rm -rf "$TARBALL_EXTRACT"
  mkdir -p "$TARBALL_EXTRACT"

  # Extract tarball
  echo "Extracting tarball..."
  tar -xzf "$tarball_path" -C "$TARBALL_EXTRACT"

  # Find the actual root directory inside the tarball
  find_tarball_root

  if [ "$scope" = "full" ]; then
    echo "Note: Full JAR extraction from tarball not implemented (use CycloneDX for Maven deps)"
    echo "Proceeding with Python package extraction only..."
  fi

  # Always extract Python packages
  extract_python_from_tarball
}

find_tarball_root() {
  # The tarball may extract directly or into a subdirectory
  TARBALL_ROOT="$TARBALL_EXTRACT"

  # Check if internal directory is at the root level
  if [ -d "$TARBALL_EXTRACT/internal" ]; then
    TARBALL_ROOT="$TARBALL_EXTRACT"
  else
    # Look for a single subdirectory that contains internal/
    # This handles tarballs that extract into a named directory (e.g., liquibase-secure-5.0.0/)
    for subdir in "$TARBALL_EXTRACT"/*/; do
      if [ -d "${subdir}internal" ]; then
        TARBALL_ROOT="${subdir%/}"
        break
      fi
    done

    # If still not found, search recursively as last resort
    if [ ! -d "$TARBALL_ROOT/internal" ]; then
      INTERNAL_DIR=$(find "$TARBALL_EXTRACT" -type d -name "internal" -print -quit 2>/dev/null)
      if [ -n "$INTERNAL_DIR" ]; then
        TARBALL_ROOT=$(dirname "$INTERNAL_DIR")
      fi
    fi
  fi

  # Verify we found a valid root
  if [ ! -d "$TARBALL_ROOT/internal" ]; then
    echo "Error: Could not find internal/ directory in tarball"
    echo "Tarball contents:"
    find "$TARBALL_EXTRACT" -maxdepth 3 -type d
    exit 1
  fi

  echo "Tarball root: $TARBALL_ROOT"
}

extract_python_from_tarball() {
  echo "Scanning extension JARs for Python packages..."
  mkdir -p "${EXTRACT_DIR}/python-packages"
  mkdir -p "${EXTRACT_DIR}/extension-scan"

  # Process extension JARs (where liquibase-checks lives)
  if [ -d "$TARBALL_ROOT/internal/extensions" ]; then
    echo "Found internal/extensions directory"
    extract_python_from_extensions "$TARBALL_ROOT/internal/extensions"
  else
    echo "Warning: No internal/extensions directory found in tarball"
    echo "Contents of tarball root:"
    ls -la "$TARBALL_ROOT" || true
  fi
}

# ============================================================================
# Shared Functions
# ============================================================================

extract_python_from_extensions() {
  local extensions_dir="$1"
  local python_found=false

  for ext_jar in "$extensions_dir"/*.jar; do
    if [ -f "$ext_jar" ]; then
      jar_name=$(basename "$ext_jar")
      echo "  Scanning $jar_name..."
      jar_extract="${EXTRACT_DIR}/extension-scan/${jar_name%.jar}"
      mkdir -p "$jar_extract"

      if ! unzip -q "$ext_jar" -d "$jar_extract" 2>&1; then
        echo "    Warning: Failed to extract $jar_name - skipping"
        continue
      fi

      # Check if this JAR contains GraalVM Python packages
      if [ -d "$jar_extract/org.graalvm.python.vfs" ]; then
        echo "    Found GraalVM Python packages in $jar_name"
        python_found=true

        # Record parent JAR relationship
        echo "${jar_name}|graalvm-python-packages" >> "${EXTRACT_DIR}/jar-mapping.txt"

        # Copy from both possible locations (Linux and Windows paths)
        if [ -d "$jar_extract/org.graalvm.python.vfs/venv/lib/python3.11/site-packages" ]; then
          cp -r "$jar_extract/org.graalvm.python.vfs/venv/lib/python3.11/site-packages"/* "${EXTRACT_DIR}/python-packages/" 2>/dev/null || true
          echo "    Extracted Python site-packages (Linux path)"
        fi
        if [ -d "$jar_extract/org.graalvm.python.vfs/venv/Lib/site-packages" ]; then
          cp -r "$jar_extract/org.graalvm.python.vfs/venv/Lib/site-packages"/* "${EXTRACT_DIR}/python-packages/" 2>/dev/null || true
          echo "    Extracted Python site-packages (Windows path)"
        fi

        # Also extract bundled wheels
        if [ -d "$jar_extract/META-INF/resources/libpython/ensurepip/_bundled" ]; then
          mkdir -p "${EXTRACT_DIR}/python-bundled"
          cp "$jar_extract/META-INF/resources/libpython/ensurepip/_bundled"/*.whl "${EXTRACT_DIR}/python-bundled/" 2>/dev/null || true
          echo "    Extracted bundled Python wheels"
        fi
      fi
    fi
  done

  if [ "$python_found" = false ]; then
    echo "Warning: No GraalVM Python packages found in any extension JARs"
  fi
}

create_manifest() {
  echo "Creating JAR manifest..."
  MANIFEST="${EXTRACT_DIR}/scanned-jars.txt"

  # Initialize empty manifest
  > "$MANIFEST"

  # List lib JARs (docker mode with full scope)
  if [ -d "${EXTRACT_DIR}/internal-jars/lib" ]; then
    ls -1 "${EXTRACT_DIR}/internal-jars/lib/"*.jar 2>/dev/null | xargs -n1 basename 2>/dev/null >> "$MANIFEST" || true
  fi

  # List extension JARs (docker mode with full scope)
  if [ -d "${EXTRACT_DIR}/internal-jars/extensions" ]; then
    ls -1 "${EXTRACT_DIR}/internal-jars/extensions/"*.jar 2>/dev/null | xargs -n1 basename 2>/dev/null >> "$MANIFEST" || true
  fi

  # List nested JARs from dist archives (docker mode with full scope)
  if [ -d "${EXTRACT_DIR}/dist" ]; then
    find "${EXTRACT_DIR}/dist" -type d -name "*-nested-jars" -exec ls -1 {} \; 2>/dev/null | xargs -n1 basename 2>/dev/null >> "$MANIFEST" || true
  fi

  # For tarball mode, list JARs from tarball root
  if [ -n "$TARBALL_ROOT" ]; then
    if [ -d "$TARBALL_ROOT/internal/lib" ]; then
      find "$TARBALL_ROOT/internal/lib" -name "*.jar" -type f 2>/dev/null | xargs -n1 basename 2>/dev/null >> "$MANIFEST" || true
    fi
    if [ -d "$TARBALL_ROOT/internal/extensions" ]; then
      find "$TARBALL_ROOT/internal/extensions" -name "*.jar" -type f 2>/dev/null | xargs -n1 basename 2>/dev/null >> "$MANIFEST" || true
    fi
  fi

  # Sort and deduplicate
  sort -u -o "$MANIFEST" "$MANIFEST"

  manifest_count=$(wc -l < "$MANIFEST" 2>/dev/null | tr -d ' ' || echo 0)
  echo "Created manifest with ${manifest_count} JAR files"
}

print_summary() {
  echo ""
  echo "Extraction Summary:"
  echo "==================="

  total_files=$(find "${EXTRACT_DIR}" -type f 2>/dev/null | wc -l | tr -d ' ')
  echo "Total files extracted: $total_files"

  if [ -d "${EXTRACT_DIR}/dist" ]; then
    if [ -d /tmp/liquibase-dist ]; then
      dist_archives=$(find /tmp/liquibase-dist -name "*.tar.gz" -type f 2>/dev/null | wc -l)
      dist_jars=$(find /tmp/liquibase-dist -name "*.jar" -type f 2>/dev/null | wc -l)
      nested_jars=$(find "${EXTRACT_DIR}/dist" -type d -name "*-nested-jars" -exec sh -c 'ls -1 "{}"/*.jar 2>/dev/null | wc -l' \; 2>/dev/null | awk '{s+=$1} END {print s}')
      echo "Distribution archives: $dist_archives"
      echo "  - JARs in archives: $dist_jars"
      if [ "$nested_jars" -gt 0 ] 2>/dev/null; then
        echo "  - Spring Boot nested JARs: $nested_jars"
      fi
    fi
  fi

  if [ -d "${EXTRACT_DIR}/internal-jars" ]; then
    lib_jars=$(ls -1 "${EXTRACT_DIR}/internal-jars/lib/"*.jar 2>/dev/null | wc -l)
    ext_jars=$(ls -1 "${EXTRACT_DIR}/internal-jars/extensions/"*.jar 2>/dev/null | wc -l)
    total_internal=$((lib_jars + ext_jars))
    echo "Internal JARs preserved: $total_internal"
    echo "  - Lib JARs: $lib_jars"
    echo "  - Extension JARs: $ext_jars"
  fi

  if [ -d "${EXTRACT_DIR}/python-packages" ]; then
    python_pkgs=$(find "${EXTRACT_DIR}/python-packages" -type d \( -name "*.dist-info" -o -name "*.egg-info" \) 2>/dev/null | wc -l | tr -d ' ')
    echo "Python packages found: $python_pkgs"
  fi

  if [ -d "${EXTRACT_DIR}/python-bundled" ]; then
    wheel_count=$(find "${EXTRACT_DIR}/python-bundled" -name "*.whl" 2>/dev/null | wc -l | tr -d ' ')
    echo "Bundled wheels found: $wheel_count"
  fi

  manifest_count=$(wc -l < "${EXTRACT_DIR}/scanned-jars.txt" 2>/dev/null | tr -d ' ' || echo 0)
  echo "JARs in manifest: $manifest_count"

  echo ""
  echo "Extraction complete"
}

# ============================================================================
# Main
# ============================================================================

main() {
  parse_arguments "$@"
  validate_arguments

  echo "Mode: $MODE"
  echo "Source: $SOURCE"
  echo "Scope: $SCOPE"
  echo "Extract directory: $EXTRACT_DIR"
  echo ""

  # Create extraction directory
  mkdir -p "${EXTRACT_DIR}"

  # Initialize jar-mapping.txt
  > "${EXTRACT_DIR}/jar-mapping.txt"

  case "$MODE" in
    docker)
      extract_from_docker "$SOURCE" "$SCOPE"
      ;;
    tarball)
      extract_from_tarball "$SOURCE" "$SCOPE"
      ;;
  esac

  create_manifest
  print_summary
}

main "$@"
